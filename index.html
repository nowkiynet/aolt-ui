<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AOLT – Challenge UI</title>
  <style>
    html, body { height: 100%; margin: 0; background: #111; }
    .wrap { height: 100%; display: grid; place-items: center; }
    canvas { image-rendering: pixelated; image-rendering: crisp-edges; }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="ui" width="252" height="140"></canvas>
</div>

<script>
const W = 252, H = 140;
const INSIDE_X = 9, INSIDE_Y = 18, INSIDE_W = 234, INSIDE_H = 113;

const PANEL_COLS = 9;
const SLOT_SIZE = 18;
const PANEL_HEADER_H = 12;
const PANEL_PADDING = 4;
const PANEL_SPACING = 8;

const canvas = document.getElementById("ui");
const ctx = canvas.getContext("2d");

let scale = 3; // kannst du dynamisch machen
canvas.style.width  = (W * scale) + "px";
canvas.style.height = (H * scale) + "px";

let assets = {};
let state = null;
let scrollY = 0;

function loadImage(name, src) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(assets[name] = img);
    img.onerror = rej;
    img.src = src;
  });
}

async function loadAssets() {
  await Promise.all([
    loadImage("window",  "./assets/window.png"),
    loadImage("slot",    "./assets/slot.png"),
    loadImage("confirm", "./assets/confirm.png"),
    loadImage("bg",      "./assets/bg_deepslate.png"),
  ]);
}

async function fetchState() {
  const r = await fetch("./challenge_state.json?ts=" + Date.now(), { cache: "no-store" });
  state = await r.json();
}

// --- Drawing helpers ---
function drawTiledBackground(img, x, y, w, h, tile=16) {
  for (let oy = -tile; oy < h + tile; oy += tile) {
    for (let ox = -tile; ox < w + tile; ox += tile) {
      ctx.drawImage(img, x + ox, y + oy, tile, tile);
    }
  }
}

function clipRect(x, y, w, h) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.clip();
}

function unclip() { ctx.restore(); }

function drawWindowFrame() {
  // window.png ist 256er atlas im game; deine Datei sollte bereits passend zugeschnitten sein
  ctx.drawImage(assets.window, 0, 0, W, H);
}

function fmtLootTable(id) {
  // minimal: du kannst später deine große switch-map als JSON-lookup liefern
  return id.replaceAll("_", " ");
}

function drawDetailInside() {
  if (!state) return;

  const x = INSIDE_X, y = INSIDE_Y;

  clipRect(x, y, INSIDE_W, INSIDE_H);

  // background tiles inside
  drawTiledBackground(assets.bg, x, y, INSIDE_W, INSIDE_H);

  // content origin (wie translate in Java)
  let cursorY = y + 4 + scrollY;

  for (const panel of (state.panels || [])) {
    const items = panel.items || [];
    const rows = Math.ceil(items.length / PANEL_COLS);
    const panelW = PANEL_COLS * SLOT_SIZE + PANEL_PADDING * 2;
    const innerH = rows * SLOT_SIZE;
    const panelH = PANEL_HEADER_H + PANEL_PADDING + innerH + PANEL_PADDING;

    const panelX = x + Math.floor((INSIDE_W - panelW) / 2);
    const panelY = cursorY;

    // panel box
    ctx.fillStyle = "#000"; ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.fillStyle = "#404040"; ctx.fillRect(panelX+1, panelY+1, panelW-2, panelH-2);

    // header text
    ctx.fillStyle = "#fff";
    ctx.font = "8px sans-serif";
    ctx.fillText(fmtLootTable(panel.tableId || ""), panelX + 5, panelY + 10);

    const slotsOX = panelX + PANEL_PADDING;
    const slotsOY = panelY + PANEL_HEADER_H + PANEL_PADDING;

    for (let i=0; i<items.length; i++) {
      const it = items[i];
      const col = i % PANEL_COLS;
      const row = Math.floor(i / PANEL_COLS);
      const sx = slotsOX + col * SLOT_SIZE;
      const sy = slotsOY + row * SLOT_SIZE;

      // slot background sprite (18x18)
      ctx.drawImage(assets.slot, sx, sy, 18, 18);

      // placeholder item: wir rendern erstmal nur “?”
      // (später: item icons als pngs oder atlas)
      ctx.fillStyle = "#ddd";
      ctx.font = "10px monospace";
      ctx.fillText("?", sx + 7, sy + 12);

      const required = it.required ?? 1;
      const have = it.have ?? 0;
      const done = have >= required;

      if (done) {
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(sx+1, sy+1, 16, 16);
        ctx.drawImage(assets.confirm, sx+1, sy-1, 18, 18);
      }
    }

    cursorY += panelH + PANEL_SPACING;
  }

  unclip();
}

function drawTitleText() {
  if (!state) return;
  ctx.fillStyle = "#3f3f3f";
  ctx.font = "10px sans-serif";
  ctx.fillText(state.title || "ALL & ONLY: LootTables", 8, 12);
}

// --- Scrolling ---
function computeContentHeight() {
  if (!state) return 0;
  let h = 0;
  const panels = state.panels || [];
  for (let i=0; i<panels.length; i++) {
    const items = panels[i].items || [];
    const rows = Math.ceil(items.length / PANEL_COLS);
    const innerH = rows * SLOT_SIZE;
    const panelH = PANEL_HEADER_H + PANEL_PADDING + innerH + PANEL_PADDING;
    h += panelH;
    if (i < panels.length - 1) h += PANEL_SPACING;
  }
  return h + 8; // top/bottom slack
}

function clampScroll() {
  const contentH = computeContentHeight();
  if (contentH <= INSIDE_H) { scrollY = 0; return; }
  const min = -(contentH - INSIDE_H);
  const max = 0;
  scrollY = Math.max(min, Math.min(max, scrollY));
}

canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  scrollY -= Math.sign(e.deltaY) * 16; // wie dein dy*16
  clampScroll();
  render();
}, { passive: false });

// --- Main render ---
function render() {
  ctx.clearRect(0,0,W,H);

  // inside first, then window (wie in Java)
  drawDetailInside();
  drawWindowFrame();
  drawTitleText();
}

async function main() {
  await loadAssets();
  await fetchState();
  clampScroll();
  render();

  // auto refresh state
  setInterval(async () => {
    await fetchState();
    clampScroll();
    render();
  }, 15000);
}

main().catch(console.error);
</script>
</body>
</html>
